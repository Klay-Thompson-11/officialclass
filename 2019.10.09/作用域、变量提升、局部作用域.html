<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    <script>
    /*
    作用域（scope）：js运行的范围

    当打开浏览器时，解读到script标签时，会把js运行在一个window的全局作用域下（整个window下的环境都叫全局作用域）
    一个变量或者一个函数，默认属于window
    在运行函数时，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有变量、函数存储到这个活动变量下，执行栈去运行这个活动变量，这些活动变量下的变量、函数只会作用在函数内，这种现象就叫局部作用域。
    */

    console.log(a);//undefined
    var a=10;
    console.log(a);//10

    function a(){}

    function fn(){
        var a=20;
        return a;
    }
    console.log(fn());


    function f(){
        console.log(this);//window
    }
    f();
    console.log(window.f);

    /*
    变量提升（预解析机制）：
    当浏览器去解析js时，会提前解析全局的变量或者函数的过程。
    第一步：
     上来找var和function
     第二步：
     逐行解读代码，此时var和function就不用再去读了。
     一般读的是赋值、计算、输出、判断
    */

    console.log(a);//function a(){console.log(4)}
    a();
    function a(){console.log(1)}
    a();
    var a=function(){console.log(2)}
    a();
    var a=10;
    var a =function(){console.log(3)}
    a();
    console.log(a);//function(){console.log(3)}
    a();
    function a(){console.log(4)}
    a();
    console.log(a);//function(){console.log(3)}
    a();

    /*
    一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名的变量，结果都等于这个有名函数
    */

    var a=10;
    (function a(){
        a={};
        console.log(a);
    })();

    console.log(a);//function a(){console.log(3)}
    a();
    function a(){console.log(1)}
    a();
    function a(){console.log(2)}
    var a=10;
    function a(){console.log(3)}
    console.log(a);//10
    a();
    console.log();//不执行


    console.log(a);//function a(){
                   // alert(2);
                     //}
    a();
    function a(){
        alert(1);
    }
    var a=10;
    console.log(a);//10
    function a(){
        alert(2);
    }
    a();


    console.log(a); //function a(){}
    function a(){}
    console.log(a);//function a(){}
    var a = 10;
    console.log(a);//10



    function a(){}
    console.log(a); //function a(){}
    var a = 10;
    console.log(a);//10
    var a = 20; 
    console.log(a);//20

/*
function fn(){

}
fn()

函数调用时，开辟一个栈内存
1.形参赋值
2.变量提升
3.执行上下文
4.执行栈销毁（变量和参数）
*/

function fn(a){
    console.log(a);//function a(){}
    var a=20;
    function a(){}
}
fn(function(){console.log(1111)});



var a = 20;
    function fn(a){
        console.log(a);//function a(){}
        var b = 6; 
        var a = 5;
        function a(){}
        console.log(a);//5
    }
    fn(function(){});


     var a = 20; 
    function fn(a){
        console.log(a);//20
        var b = 6; 
        var a = 5;
        console.log(b,a); //6,5
    }
    fn(a);

     var a = 10;
    function fn(){
        console.log(a);//undefined
        var a = 5;
        console.log(a);//5
    }
    fn(5);



    var a = 10;
    function fn(a){
        console.log(a);//5
    }
    fn(5);
    </script>
</body>
</html>