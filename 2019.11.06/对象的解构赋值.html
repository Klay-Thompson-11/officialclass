<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>

    /*
        let {key1,key2} = {key1:val1,key2:val2}

        在声明的时候使用块声明，块中放对象的key值，这里的key值一定要
        和解构对象的key值名字保持一致

        如果要取别名，使用:新定义的名字即可
            let {key1:k,key2} = {key1:val1,key2:val2}

        此时key1已经访问不到了，要访问就报错，只能访问k，k就代表key1，
        名字跟声明变量规则一致

        如果加了:不报错，那么可以先解构一次，再重命名
            let {
                f,  //先把f解构出来，这样就可以访问f了
                f:x
            } = {
               f:{
                    name:'11',
                    age:22
               }
            }
    */
    let obj = {
        type: "sug", 
        sa: "s_2",
        q: "赵某***",
        s:"某炎**母猪"
    }    

    let {type:t,q,s} = obj;
    console.log(type,q,s);
    console.log(t);

    console.log(obj.type);
    console.log(obj.q);
    console.log(obj.s);

    let {log,dir} = console;

    log(1);

    let obj = {
        p: [
            'Hello',
            {
                y: 'World',
                z:{
                    x:[
                        {
                            j:0
                        }
                    ]
                }
            }
        ]
    };
    let {p:[x,{y,z:{x:[{j}]}}]} = obj

    console.log(j);


    const node = {
        loc: {
            start: {
                line: 1,
                column: 5
            }
        }
    };

    let { loc, loc: { start }, loc: { start: { line }} } = node;

    console.log(line);


    let {
        f,
        f:x
    } = {
        f:{
            name:'11',
            age:22
        }
    }

    console.log(f)


    let obj = {};
    let arr = [];
    ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

    console.log(obj,arr);
    obj.prop = {}.foo;

    var {x, y = 5} = {x: 1};
    console.log(x,y);

    let {value:val} = input

    function fn({age:{b}}){
        console.log(b);
    }

    fn({name:'某炎',age:{s:1,b:2}})


    function move({x, y} = { x: 0, y: 0 }) {
        return [x, y];
    }
    /**
        传了对象那么就按照传的对象来解析，不会按照默认的来解析 
    **/
    const {log} = console;
    log(move({x: 3, y: 8}));  //3,8
    log( move( {x: 3} )); //3,undefined
    log( move({}));//undefined,undefined
    log(move());//0,0
    log([1, undefined, 3].map((item='yes') => item) );

</script>
</body>
</html>