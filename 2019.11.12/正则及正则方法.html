<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
      /*
        正则表达式:
            专门用来检索字符串的一种规则（更擅长处理模糊范围的字符串）
     -> 字面量的写法
     -> new RegExp(规则【可以为字符串的，可以进行字符串拼接】,修饰符) -> new实例的写法
    */  
   
    let str = 'abc';
    let aa = 'a';
    // *** 什么时候用字面量写法什么时候用new RegExp
    console.log(/aa/); // 找的是字符aa(正则里面放的是不带引号的字符串或者规则)
    console.log(new RegExp(aa)); //找的是变量aa，其实就是找字符串a


    //   \ ：转义字符   把正则中有特殊含义的字符 转成字符本身(不再有任何特殊的含义),转义符转的是\后面的字符
 
    /*
        正则身上的方法:
            //.exec(字符串)
                找到正则匹配的字符串（首次出现的字符【就一次】），并且放到数组中(返回的是数组)
            
            
            //.test(字符串)
                查看字符串中是否有规则匹配项，如果有就返回true，否则false


        特殊转义符:
            \d  一个0-9的数字

        量词:
            +  至少出现1次，最多不限

        修饰符:
            g -> global 全局查找

    */   

    // console.log(typeof /a/);//object
    // console.log(Object.prototype.toString.call(/a/));

    // let str = 'dh8137289371299dx1';

    /*
        ["1", index: 3, input: "dh819dx1", groups: undefined]

        '1'为找到的字符
        index: '1'首次出现的位置
        input:整个字符
        groups:undefined
        length:1  (因为找的是'1'这个字符串)
    */
    // console.log(/\d+/.exec(str)); //查看字符串中是否有正则匹配项

    let str = 'dh8137289371299zdx1'; 
    console.log(/z/.test(str));// 找当前字符串中是否有z这个字符


     /*
        string.match(//)  是字符串的方法
            找到正则匹配的字符并且把它们放到数组中（返回值是数组）

        跟exec类似

        正则的懒惰性: 
            你让它找一个，绝对不会找第二个，你让它找一堆，它绝对不会找第二堆

        正则的贪婪性:
            只要符合某个规则就不停的找，直到找不到为止

        i : 忽略大小写  ignoreCase
                
    */   

    // let str = '32632321323rgb087yr23n6x832321';
    // console.log(str.match(/\d+/g));

    let str = '37z89z37Z218Z9';

    console.log(str.match(/z/gi));//查找全局是否有z(不管大写还是小写)


</script>
</body>
</html>