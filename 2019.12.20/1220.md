> get:
  url的方式请求（可暴露的）
   www.baidu.com
   路径：localhost/1.html || localhost/static/1.html
   接口：localhost/api?user=login

```
   fetch('/api?wd=qqq')
   xhr.open('get','/api?wd=qqq');
   $.ajax({
       url:'/api',
       data:{
           wd='qqq'
       }
   })

```

> post:
  
  服务端（不可暴露）
```
  localhost/api/post
  
```
```
  send(userqqq&pw=123)

```
```
  script src='localhost/s?wd=qqq'

```


到底是get还是post，有两种方式可以得到，
  第一种：接口文档
  第二种：自己测、问


### fetch 和 axios 的区别

fetch：ES6新增的api，基于promise  get post

axios：基于promise封装的XMLHttpRequest

axios里面有拦截器，方便做钩子处理


XMLHttpRequest可以监听细节，监听请求过程1-4
超时处理、abort强制中断，onabort中断监听


### generator

调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）

总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。一开始函数是不会执行的，因为它是个状态对象。

如何让这个Generator函数执行？

每次调用遍历器对象的next方法，就会返回一个有着value和done的两个属性对象。
{value:xxx,done:false}

value属性表示当前的内部状态值，是yield或者return表达式后面的那个表达式的值；
done属性是一个布尔值，表示是否遍历结束，false代表没结束，true代表结束了。

### Symbol.interator

interator的作用有三个：
  一是为各种数据结构，提供一个统一的2、简便的访问接口；
  二是使得数据结构的成员能够按某种次序排列；
  三是ES6创造了一种新的遍历命令for...of循环，Interator接口主要供for...of消费。

### for of

统一的遍历api

一个数据结构只要部署了Symbol.interator属性，就被视为具有interator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.interator方法。

要遍历key -> ary.keys()
要遍历value -> ary.values()
都要遍历 -> ary.entries()

字符串、数组、Map、Set、QuerySelectorAll都有Symbol.interator
